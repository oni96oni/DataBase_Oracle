DECLARE --SQL문실행과, SQL스크립트실행은 다르다.
	x NUMBER;
	y NUMBER := 0;
	z CONSTANT NUMBER := 20; --상수지정

BEGIN
	x := 10;
	DBMS_OUTPUT.PUT_LINE('변수 x -> ' || x);
	DBMS_OUTPUT.PUT_LINE('변수 y -> ' || y);
	DBMS_OUTPUT.PUT_LINE('상수 z -> ' || z);
END;


DECLARE
	str VARCHAR2(10);
BEGIN
	str := 'Hello';
	DBMS_OUTPUT.PUT_LINE(str);
END;


DECLARE
	EMP_ID EMPLOYEES.EMPLOYEE_ID%TYPE; --길이를 현재 내가 정할수가 없을때
	EMP_NAME VARCHAR(100);
BEGIN
	SELECT EMPLOYEE_ID
		 , FIRST_NAME
	  INTO EMP_ID, EMP_NAME
	  FROM EMPLOYEES 
	 WHERE EMPLOYEE_ID = 100;
	
	DBMS_OUTPUT.PUT_LINE(EMP_ID || '/' || EMP_NAME);
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; --한 행에 대한 ROWTYPE변수의 선언과 초기화, 값 출력
BEGIN
	SELECT *
	  INTO EMP
	  FROM EMPLOYEES 
	 WHERE EMPLOYEE_ID = 100;
	
	DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.FIRST_NAME);
	DBMS_OUTPUT.PUT_LINE(EMP.SALARY || '/' || EMP.COMMISSION_PCT);
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
	ID NUMBER := 100;
BEGIN
	LOOP
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.FIRST_NAME);

		ID := ID + 1;

		IF(ID >= 150) THEN
			EXIT;
		END IF;
	END LOOP;
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
	ID NUMBER := 100;
BEGIN
	LOOP
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY);
		ELSE
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		ID := ID + 1;

		IF(ID >= 150) THEN
			EXIT;
		END IF;
	END LOOP;
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
	ID NUMBER := 100;
BEGIN
	LOOP
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY);
		ELSIF (NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		ID := ID + 1;

		IF(ID >= 150) THEN
			EXIT;
		END IF;
	END LOOP;
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
BEGIN
	FOR ID IN 100..150 LOOP -- 내가 정확히 원하는 범위만 실행 알아서 +1이 되어서 증감연산자 필요X
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY);
		ELSIF (NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;

	END LOOP;
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
BEGIN
	FOR ID IN REVERSE 100..150 LOOP -- REVERSE 사용하면 거꾸로!
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY);
		ELSIF (NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;

	END LOOP;
END;


DECLARE
	EMP EMPLOYEES%ROWTYPE; 
	ID NUMBER := 100;
BEGIN
	WHILE ID <= 150 LOOP --WHILE문을 사용하는 반복문
	 	SELECT *
		  INTO EMP
		  FROM EMPLOYEES 
		 WHERE EMPLOYEE_ID = ID;
	
		IF(NVL(EMP.COMMISSION_PCT, 0) = 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY);
		ELSIF (NVL(EMP.COMMISSION_PCT, 0) > 0) THEN
			DBMS_OUTPUT.PUT_LINE(EMP.EMPLOYEE_ID || '/' || EMP.SALARY * (1 + EMP.COMMISSION_PCT));
		END IF;
		
		ID := ID + 1;
	END LOOP;
END;

SELECT * FROM EMPLOYEES e ;